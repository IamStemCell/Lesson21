#Task 1 
#File Context Manager class
#Create your own class, which can behave like a built-in function `open`.
#Also, you need to extend its functionality with counter and logging.
#Pay special attention to the implementation of `__exit__` method,
#which has to cover all the requirements to context managers.

class FileContManager:
    def __init__(self, file_path, mode):
        self.file_path = file_path
        self.mode = mode
        self.file_obj = None
        self.counter = 0
    
    def __enter__(self):
        self.file_obj = open(self.file_path, self.mode)
        self.counter += 1
        return self.file_obj
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.counter -= 1
        self.file_obj.close()
        if exc_type is not None:
            logging.error(f"Exception {exc_type} occurred in context manager for file {self.file_path}")
            return False
        return True


#Приклад використання:

with FileContManager("newfile.txt", "w") as file:
    file.write("Hello, Python world!")



#Task2
import unittest
import os
from python_practice import FileContManager

class TestFileContManager(unittest.TestCase):

    def test_file_open_and_close(self):
        with FileContManager('test.txt', 'w') as fcm:
            fcm.write('Hello, world!')
        with open('test.txt', 'r') as f:
            self.assertEqual(f.read(), 'Hello, world!')

    def test_file_already_exists(self):
        with open('test.txt', 'w') as f:
            f.write('This is an existing file.')
        with self.assertRaises(FileExistsError):
            with FileContManager('test.txt', 'w') as fcm:
                pass

    def test_runtime_error(self):
        with self.assertRaises(RuntimeError):
            with FileContManager('test.txt', 'w') as fcl:
                raise RuntimeError('Test error')


if __name__ == '__main__':
    unittest.main()


import unittest
import os
from tempfile import TemporaryDirectory


class TestFileContManager(unittest.TestCase):
    def setUp(self):
        self.temp_dir = TemporaryDirectory()
        self.file_path = os.path.join(self.temp_dir.name, 'test.txt')
    
    def tearDown(self):
        self.temp_dir.cleanup()
    
    def test_file_creation(self):
        with FileContManager(self.file_path, 'w') as f:
            self.assertTrue(os.path.exists(self.file_path))
            self.assertEqual(f.mode, 'w')
    
    def test_file_writing(self):
        with FileContManager(self.file_path, 'w') as f:
            f.write('Hello, world!')
        with open(self.file_path) as f:
            self.assertEqual(f.read(), 'Hello, world!')
    
    def test_file_reading(self):
        with open(self.file_path, 'w') as f:
            f.write('Hello, world!')
        with FileContManager(self.file_path, 'r') as f:
            self.assertEqual(f.read(), 'Hello, world!')
    
    def test_exception_handling(self):
        with self.assertRaises(Exception):
            with FileContManager(self.file_path, 'r') as f:
                1 / 0
    
    def test_multiple_instances(self):
        with FileContManager(self.file_path, 'w') as f1:
            f1.write('Hello, world!')
            with FileContManager(self.file_path, 'r') as f2:
                self.assertEqual(f2.read(), 'Hello, world!')
            f1.write('Goodbye, world!')
        with open(self.file_path) as f:
            self.assertEqual(f.read(), 'Hello, world!Goodbye, world!')
    
    def test_context_manager_exit(self):
        with self.assertRaises(AttributeError):
            with FileContManager(self.file_path, 'w') as f:
                raise AttributeError()
        self.assertFalse(os.path.exists(self.file_path))

if __name__ == '__main__':
    unittest.main()

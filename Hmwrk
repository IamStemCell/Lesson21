#Task 1 
#File Context Manager class
#Create your own class, which can behave like a built-in function `open`.
#Also, you need to extend its functionality with counter and logging.
#Pay special attention to the implementation of `__exit__` method,
#which has to cover all the requirements to context managers.

class FileContManager:
    def __init__(self, file_path, mode):
        self.file_path = file_path
        self.mode = mode
        self.file_obj = None
        self.counter = 0
    
    def __enter__(self):
        self.file_obj = open(self.file_path, self.mode)
        self.counter += 1
        return self.file_obj
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.counter -= 1
        self.file_obj.close()
        if exc_type is not None:
            logging.error(f"Exception {exc_type} occurred in context manager for file {self.file_path}")
            return False
        return True


#Приклад використання:

with FileContManager("newfile.txt", "w") as file:
    file.write("Hello, Python world!")



#Task2
import unittest
import os
from python_practice import FileContManager

class TestFileCountManager(unittest.TestCase):

    def test_file_open_and_close(self):
        with FileCountManager('test.txt', 'w') as fcm:
            fcm.write('Hello, world!')
        with open('test.txt', 'r') as f:
            self.assertEqual(f.read(), 'Hello, world!')

    def test_file_already_exists(self):
        with open('test.txt', 'w') as f:
            f.write('This is an existing file.')
        with self.assertRaises(FileExistsError):
            with FileCountManager('test.txt', 'w') as fcm:
                pass

    def test_runtime_error(self):
        with self.assertRaises(RuntimeError):
            with FileCountManager('test.txt', 'w') as fcl:
                raise RuntimeError('Test error')


if __name__ == '__main__':
    unittest.main()
